{"version":3,"file":"node-set.test.js","sourceRoot":"","sources":["../src/node-set.test.ts"],"names":[],"mappings":"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","sourcesContent":["import {describe, expect, test} from '@jest/globals';\nimport {NodeSet} from './node-set.js';\n\ndescribe(`NodeSet`, () => {\n  test(`static any()`, () => {\n    expect(NodeSet.any().expression).toBe(`descendant-or-self::node()`);\n  });\n\n  test(`static attribute()`, () => {\n    expect(\n      [\n        NodeSet.attribute(`foo`),\n        NodeSet.attribute(`.foo`),\n        NodeSet.attribute(`#foo`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `attribute::foo`,\n      `attribute::class[contains(concat(\" \", normalize-space(self::node()), \" \"), \" foo \")]`,\n      `attribute::id[(self::node() = \"foo\")]`,\n    ]);\n  });\n\n  test(`static comment()`, () => {\n    expect(\n      [\n        NodeSet.comment(),\n        NodeSet.comment(`ancestor-or-self`),\n        NodeSet.comment(`ancestor`),\n        NodeSet.comment(`child`),\n        NodeSet.comment(`descendant-or-self`),\n        NodeSet.comment(`descendant`),\n        NodeSet.comment(`following-sibling`),\n        NodeSet.comment(`following`),\n        NodeSet.comment(`parent`),\n        NodeSet.comment(`preceding-sibling`),\n        NodeSet.comment(`preceding`),\n        NodeSet.comment(`self`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `child::comment()`,\n      `ancestor-or-self::comment()`,\n      `ancestor::comment()`,\n      `child::comment()`,\n      `descendant-or-self::comment()`,\n      `descendant::comment()`,\n      `following-sibling::comment()`,\n      `following::comment()`,\n      `parent::comment()`,\n      `preceding-sibling::comment()`,\n      `preceding::comment()`,\n      `self::comment()`,\n    ]);\n  });\n\n  test(`static element()`, () => {\n    expect(\n      [\n        NodeSet.element(`foo`),\n        NodeSet.element(`foo`, `ancestor-or-self`),\n        NodeSet.element(`foo`, `ancestor`),\n        NodeSet.element(`foo`, `child`),\n        NodeSet.element(`foo`, `descendant-or-self`),\n        NodeSet.element(`foo`, `descendant`),\n        NodeSet.element(`foo`, `following-sibling`),\n        NodeSet.element(`foo`, `following`),\n        NodeSet.element(`foo`, `parent`),\n        NodeSet.element(`foo`, `preceding-sibling`),\n        NodeSet.element(`foo`, `preceding`),\n        NodeSet.element(`foo`, `self`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `child::foo`,\n      `ancestor-or-self::foo`,\n      `ancestor::foo`,\n      `child::foo`,\n      `descendant-or-self::foo`,\n      `descendant::foo`,\n      `following-sibling::foo`,\n      `following::foo`,\n      `parent::foo`,\n      `preceding-sibling::foo`,\n      `preceding::foo`,\n      `self::foo`,\n    ]);\n  });\n\n  test(`static namespace()`, () => {\n    expect(NodeSet.namespace(`foo`).expression).toBe(`namespace::foo`);\n  });\n\n  test(`static node()`, () => {\n    expect(\n      [\n        NodeSet.node(),\n        NodeSet.node(`ancestor-or-self`),\n        NodeSet.node(`ancestor`),\n        NodeSet.node(`child`),\n        NodeSet.node(`descendant-or-self`),\n        NodeSet.node(`descendant`),\n        NodeSet.node(`following-sibling`),\n        NodeSet.node(`following`),\n        NodeSet.node(`parent`),\n        NodeSet.node(`preceding-sibling`),\n        NodeSet.node(`preceding`),\n        NodeSet.node(`self`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `child::node()`,\n      `ancestor-or-self::node()`,\n      `ancestor::node()`,\n      `child::node()`,\n      `descendant-or-self::node()`,\n      `descendant::node()`,\n      `following-sibling::node()`,\n      `following::node()`,\n      `parent::node()`,\n      `preceding-sibling::node()`,\n      `preceding::node()`,\n      `self::node()`,\n    ]);\n  });\n\n  test(`static parent()`, () => {\n    expect(NodeSet.parent().expression).toBe(`parent::node()`);\n  });\n\n  test(`static processingInstruction()`, () => {\n    expect(\n      [\n        NodeSet.processingInstruction(),\n        NodeSet.processingInstruction(`ancestor-or-self`),\n        NodeSet.processingInstruction(`ancestor`),\n        NodeSet.processingInstruction(`child`),\n        NodeSet.processingInstruction(`descendant-or-self`),\n        NodeSet.processingInstruction(`descendant`),\n        NodeSet.processingInstruction(`following-sibling`),\n        NodeSet.processingInstruction(`following`),\n        NodeSet.processingInstruction(`parent`),\n        NodeSet.processingInstruction(`preceding-sibling`),\n        NodeSet.processingInstruction(`preceding`),\n        NodeSet.processingInstruction(`self`),\n        NodeSet.processingInstruction(`child`, `foo`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `child::processing-instruction()`,\n      `ancestor-or-self::processing-instruction()`,\n      `ancestor::processing-instruction()`,\n      `child::processing-instruction()`,\n      `descendant-or-self::processing-instruction()`,\n      `descendant::processing-instruction()`,\n      `following-sibling::processing-instruction()`,\n      `following::processing-instruction()`,\n      `parent::processing-instruction()`,\n      `preceding-sibling::processing-instruction()`,\n      `preceding::processing-instruction()`,\n      `self::processing-instruction()`,\n      `child::processing-instruction(foo)`,\n    ]);\n  });\n\n  test(`static root()`, () => {\n    expect(NodeSet.root().expression).toBe(`/`);\n  });\n\n  test(`static self()`, () => {\n    expect(NodeSet.self().expression).toBe(`self::node()`);\n  });\n\n  test(`static text()`, () => {\n    expect(\n      [\n        NodeSet.text(),\n        NodeSet.text(`ancestor-or-self`),\n        NodeSet.text(`ancestor`),\n        NodeSet.text(`child`),\n        NodeSet.text(`descendant-or-self`),\n        NodeSet.text(`descendant`),\n        NodeSet.text(`following-sibling`),\n        NodeSet.text(`following`),\n        NodeSet.text(`parent`),\n        NodeSet.text(`preceding-sibling`),\n        NodeSet.text(`preceding`),\n        NodeSet.text(`self`),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `child::text()`,\n      `ancestor-or-self::text()`,\n      `ancestor::text()`,\n      `child::text()`,\n      `descendant-or-self::text()`,\n      `descendant::text()`,\n      `following-sibling::text()`,\n      `following::text()`,\n      `parent::text()`,\n      `preceding-sibling::text()`,\n      `preceding::text()`,\n      `self::text()`,\n    ]);\n  });\n\n  test(`filter()`, () => {\n    expect(\n      [\n        NodeSet.root().filter(NodeSet.element(`foo`)).filter(`0`),\n        NodeSet.element(`foo`).filter(NodeSet.element(`bar`)).filter(`0`),\n      ].map(({expression}) => expression),\n    ).toEqual([`/[child::foo][\"0\"]`, `child::foo[child::bar][\"0\"]`]);\n  });\n\n  test(`path()`, () => {\n    expect(\n      [\n        NodeSet.root()\n          .path(NodeSet.element(`foo`).path(NodeSet.element(`bar`)))\n          .path(NodeSet.element(`baz`)),\n\n        NodeSet.element(`foo`)\n          .path(NodeSet.element(`bar`).path(NodeSet.element(`baz`)))\n          .path(NodeSet.element(`qux`)),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `/ child::foo / child::bar / child::baz`,\n      `child::foo / child::bar / child::baz / child::qux`,\n    ]);\n  });\n\n  test(`union()`, () => {\n    expect(\n      [\n        NodeSet.root()\n          .union(NodeSet.element(`foo`).union(NodeSet.element(`bar`)))\n          .union(NodeSet.element(`baz`)),\n\n        NodeSet.element(`foo`)\n          .union(NodeSet.element(`bar`).union(NodeSet.element(`baz`)))\n          .union(NodeSet.element(`qux`)),\n      ].map(({expression}) => expression),\n    ).toEqual([\n      `/ | child::foo | child::bar | child::baz`,\n      `child::foo | child::bar | child::baz | child::qux`,\n    ]);\n  });\n});\n"]}